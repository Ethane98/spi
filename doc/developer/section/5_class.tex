\section{Class Reference}

% In both user and developer manual
\subsection{Interfaces for Users}
\subsubsection{Class Agent}
\textbf{Declared in}: src/agent/agent.h

\begin{apient}
void SetInitEntry(string);
\end{apient}
\apidesc{

Sets the entry payload function name. By default, the entry payload function is
``default\_entry'', which simply prints out all executed functions' name.

}

\begin{apient}
void SetInitExit(string);
\end{apient}
\apidesc{

Sets the exit payload function name. By default, there is not exit payload
function.

}

\begin{apient}
void SetLibrariesToInstrument(const StringSet& libs);
\end{apient}
\apidesc{

Sets the set of names of libraries loaded in the application process that will
be instrumented. By default, we only instrument the executable binary code and
don't instrument loaded shared libraries.

}

\begin{apient}
void SetFuncsNotToInstrument(const StringSet& funcs);
\end{apient}
\apidesc{
Sets the set of names of functions in the application process that will
NOT be instrumented. By default, we instrument all functions.
}

\begin{apient}
void EnableParseOnly(const bool yes_or_no);
\end{apient}
\apidesc{

Enables or disables ParseOnly option. If yes\_or\_no is true, then after parsing
the binary code, we don't do instrumentation; otherwise, instrumentation is
conducted after parsing. By default, ParseOnly option is disabled.

}

\begin{apient}
void EnableIpc(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable inter-process instrumentation propagation. By default,
inter-process instrumentation propagation is disabled.

}

\begin{apient}
void EnableHandleDlopen(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable propagating instrumentation to library loaded via dlopen. By
default, it is disabled.

}

\begin{apient}
void EnableMultithread(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable propagating instrumentation across thread. By default, it is
disabled.

}

\begin{apient}
void Go();
\end{apient}
\apidesc{

Starts initial instrumentation.

}

\subsubsection{Class SpPoint}
\textbf{Declared in}: src/agent/patchapi/point.h

\begin{apient}
bool tailcall();
\end{apient}
\apidesc{

Indicates whether or not the function call at this point is a tail call.

}

\begin{apient}
SpBlock* GetBlock() const;
\end{apient}
\apidesc{

Returns the call block at this point.

}

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object at this point.
}


\subsubsection{Class SpObject}
\textbf{Declared in}: src/agent/patchapi/object.h

\begin{apient}
std::string name() const;
\end{apient}
\apidesc{
Returns the binary object's name.
}

This class inherits PatchAPI::PatchObject. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Class SpFunction}
\textbf{Declared in}: src/agent/patchapi/cfg.h

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object containing this function.
}

\begin{apient}
std::string GetMangledName();
\end{apient}
\apidesc{
Returns the mangled name of this function.
}

\begin{apient}
std::string GetPrettyName();
\end{apient}
\apidesc{
Returns the demangled name of this function.
}

\begin{apient}
std::string name();
\end{apient}
\apidesc{
Returns the demangled name of this function, the same as calling GetPrettyName().
}

This class inherits PatchAPI::PatchFunction. Please refer to PatchAPI document
for the complete list of methods.

\subsubsection{Class SpBlock}
\textbf{Declared in}: src/agent/patchapi/cfg.h

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object containing this block.
}

\begin{apient}
in::Instruction::Ptr orig_call_insn() const;
\end{apient}
\apidesc{

Returns an InstructionAPI::Instruction instance of the call instruction in this
block.

}

This class inherits PatchAPI::PatchBlock. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Class SpEdge}
\textbf{Declared in}: src/agent/patchapi/cfg.h

This class inherits PatchAPI::PatchEdge. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Utility Functions}
\textbf{Declared in}: src/agent/payload.h

Utility functions are used when writing payload functions.

\begin{apient}
SpFunction* Callee(SpPoint* pt);
\end{apient}
\apidesc{
Returns an instance of SpFunction for current function call. 
The parameter \emph{pt} represents the instrumentation point for current function
call.
If it fails, it returns NULL.
}

\begin{apient}
bool IsInstrumentable(SpPoint* pt);
\end{apient}
\apidesc{
Indicates whether or not the point is instrumentable.
}

\begin{apient}
void Propel(SpPoint* pt);
\end{apient}
\apidesc{

Propagates instrumentation to callees of the function called at the specified
point {\em pt}.

}

\begin{apient}
bool IsIpcWrite(SpPoint* pt); 
bool IsIpcRead(SpPoint* pt); 
\end{apient}
\apidesc{

Indicates whether or not the function called at the specified point is a
inter-process communication write / read function.

}

\begin{apient}
struct ArgumentHandle;
void* PopArgument(SpPoint* pt,
                  ArgumentHandle* h,
                  size_t size);
\end{apient}
\apidesc{

Gets a pointer to an parameter of the function call at the specified point {\em
  pt}.
All parameters passed to the function call are in a stack associated with the
ArgumentHandle structure {\em h}. 
Leftmost parameter is at the top of the stack.
The {\em size} parameter specifies the size of the parameter that is about to be
popped.

}

\begin{apient}
long ReturnValue(SpPoint* pt);
\end{apient}
\apidesc{
Returns the return value of the function call at the specified point {\em pt}.
}

% In developer manual only
\subsection{Interfaces for Developers}
\subsubsection{Class SpInjector}
\textbf{Declared in}: src/injector/injector.h

\begin{apient}
static ptr Create(Dyninst::PID pid);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpInjector instance.
The parameter {\em pid} specifies the pid of the remote process that will be
injected.

}

\begin{apient}
bool Inject(const char* lib_name);
\end{apient}
\apidesc{
Injects a library with {\em lib\_name}.
}


\subsubsection{Class SpParser}
\textbf{Declared in}: src/agent/parser.h

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpParser instance.
}

\begin{apient}
SpObject* exe() const;
\end{apient}
\apidesc{
Returns the executable's binary object.
}

\begin{apient}
PatchAPI::PatchMgrPtr Parse();
\end{apient}
\apidesc{ The major parsing method, which builds CFG data structures to assist
  instrumentation.  }

\begin{apient}
string agent_name()
\end{apient}
\apidesc{
Returns the agent library's full path name.
}

\begin{apient}
bool injected()
\end{apient}
\apidesc{

  Indicates whether or not this agent library is injected in the middle of
  running current process.

}

\begin{apient}
void GetFrame(long* pc, long* sp, long* bp)
\end{apient}
\apidesc{

  Get the values of three registers (pc, sp, and bp) of the call frame where the
  agent is injected. The three parameters are output parameters.

}

\begin{apient}
SpFunction* FindFunction(dt::Address absolute_addr);
\end{apient}
\apidesc{

  Returns the function that contains the address {\em absolute_addr}.
  It returns NULL if no function is found.
}

\begin{apient}
SpFunction* FindFunction(string mangled_name);
\end{apient}
\apidesc{

  Returns one of the functions that have the mangled function name.
  It returns NULL if no function is found.
}

\begin{apient}
bool FindFunction(string func_name, FuncSet* found_funcs);
\end{apient}
\apidesc{

  Get all the functions that have the demangled function name.

}

\begin{apient}
SpFunction* callee(SpPoint* point, bool parse_indirect = false);
\end{apient}
\apidesc{

  Returns the callee at the given call {\em point}.
  If {\em parse\_indirect} is false and the call instruction is an indirect call
  instruction, then we skip parsing it and return NULL immediately.
  If the callee is not found, NULL is returned.
}

\begin{apient}
string DumpInsns(void* addr, size_t size);
\end{apient}
\apidesc{

  Returns a nice textual representation of all instructions at the memory area of [{\em
    addr}, {\em addr} + size].

}

\begin{apient}
static bool ParseDlExit(SpPoint* pt);
\end{apient}
\apidesc{

  Detects the dlopen function call, and parses the library that is just loaded.
  It is invoked immediately after the dlopen function call is returned.
}

\subsubsection{Class SpContext}
\textbf{Declared in}: src/agent/context.h

\begin{apient}
static SpContext* Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpContext instance.

}

\begin{apient}
string init_entry_name() const
\end{apient}
\apidesc{
  Returns initial entry payload function's demangled name.
}

\begin{apient}
string init_exit_name() const
\end{apient}
\apidesc{
  Returns initial exit payload function's demangled name.
}

\begin{apient}
typedef std::set<SpFunction*> FuncSet;
void GetCallStack(FuncSet* func_set);
\end{apient}
\apidesc{
  Get a set of functions in the call stack, when the agent library is injected.
  {\em func\_set} is the output parameter.
}


\begin{apient}
bool IsMultithreadEnabled() const;
\end{apient}
\apidesc{
  Indicates whether instrumentation propagation across thread boundary is supported.
}

\begin{apient}
bool IsHandleDlopenEnabled() const;
\end{apient}
\apidesc{
  Indicates whether parsing newly loaded shared library is supported.
}

\begin{apient}
bool IsDirectcallOnlyEnabled() const;
\end{apient}
\apidesc{

  Indicates whether or not self-propelled instrumentation only instruments
  direct function call.

}

\begin{apient}
SpPropeller::ptr init_propeller() const;
\end{apient}
\apidesc{
  Returns an instance of SpPropeller.
}

\begin{apient}
typedef void* PayloadFunc;
PayloadFunc init_entry() const;
PayloadFunc init_exit() const;
\end{apient}
\apidesc{

  Returns the start address of user-provided entry payload function or exit
  payload function.

}

\begin{apient}
PayloadFunc wrapper_exit() const;
PayloadFunc wrapper_entry() const;
\end{apient}
\apidesc{

  Returns the start address of the wrapper of entry payload function or exit
  payload function.
  
}

\subsubsection{Events}
\textbf{Declared in}: src/agent/event.h

This is a collection of events that trigger initial instrumentation.

\textbf{Class SpEvent}

It is the base class of all event classes. This event does not trigger any
instrumentation.

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpEvent instance.

}

\begin{apient}
virtual void RegisterEvent();
\end{apient}
\apidesc{
It registers the event to agent. This function is called in Agent::Go().
}

\textbf{Class AsyncEvent}

It is the asynchronous event that will happen when specified signal occurs.

\begin{apient}
static ptr Create(int signum = SIGALRM,
                  int sec = 5);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a AsyncEvent instance.

The parameter {\em signum} specifies the signal number, and the parameter {\em
  sec} is only effective when signum is SIGALRM.

}

\textbf{Class SyncEvent}

It is the synchronous event that will do instrumentation immediately.
If the agent library is loaded via LD\_PRELOAD, then it instruments main()
function immediately.
If the agent library is injected via injector, then it instruments all functions
in the call stack when the agent library is loaded.

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SyncEvent instance.

}

\textbf{Class FuncEvent}

It instruments all of the specified functions immediately.

\begin{apient}
static ptr Create(StringSet& funcs);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a FuncEvent instance.
The parameter {\em funcs} specifies a set of demangled names of functions that
are going to be instrumented.  
}

\textbf{Class CallEvent}

It installs instrumentation at all call sites of specified functions immediately.

\begin{apient}
static ptr Create(StringSet& funcs);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a CallEvent instance.
The parameter {\em funcs} specifies a set of demangled names of function calls
that are going to be instrumented.

}

\textbf{Class CombEvent}

It is a compound event that can combine all the above events.

\begin{apient}
static ptr Create(EventSet& events);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a CombEvent instance.
The parameter {\em events} specifies a set of events.

}

\subsubsection{Class SpPropeller}
\textbf{Declared in}: src/agent/propeller.h

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpPropeller instance.

}

\begin{apient}
bool go(SpFunction* func,
        PayloadFunc entry,
        PayloadFunc exit,
        SpPoint* pt = NULL,
        StringSet* inst_calls = NULL);
\end{apient}
\apidesc{

  It propagates instrumentation to callees of specified function {\em func}.
  The parameters {\em entry} and {\em exit} specify the payload functions to be
  installed for those callees.  
  The parameter {\em point} is the point where {\em func} is invoked.
  The parameter {\em inst_calls} specifies all function calls that need to be
  instrumented, which is used only in CallEvent.

}

\subsubsection{Class SpSnippet}
\textbf{Declared in}: src/agent/snippet.h

\begin{apient}
static ptr create(SpFunction* f,
                  SpPoint* pt,
                  PayloadFunc entry,
                  PayloadFunc exit);
\end{apient}
\apidesc{
  Creates a Boost shared pointer pointing to a SpSnippet instance.
}

\begin{apient}
char* BuildBlob(const size_t est_size,
                const bool reloc = false);
\end{apient}
\apidesc{

  Returns a pointer to a blob of code snippet, which contains relocated code and
  invocations to payload functions.
  The parameter {\em est_size} specifies the estimate size to allocate the buffer
  for the code snippet.  
  The parameter {\em reloc} indicates whether or not we need to relocate a call
  block.

}

\begin{apient}
size_t GetBlobSize() const;
\end{apient}
\apidesc{
  Returns the code snippet's size.
}

\begin{apient}
SpBlock* FindSpringboard();
\end{apient}
\apidesc{
  Returns a springboard block.
}

\begin{apient}
char* RelocateSpring(SpBlock* spring_blk);
\end{apient}
\apidesc{

  Relocates the basic block {\em spring\_blk} that is used as springboard block,
  and returns the buffer containing the relocated springboard block.

}

\begin{apient}
size_t GetRelocSpringSize() const;
\end{apient}
\apidesc{
  Returns the relocated springboard block size.
}

\begin{apient}
Dyninst::Address GetSavedReg(Dyninst::MachRegister reg);
\end{apient}
\apidesc{
  Returns the value of a saved register {\em reg}.
}

\begin{apient}
long GetRetVal();
\end{apient}
\apidesc{
  Returns the return value of current function call.
}

\begin{apient}
void* PopArgument(ArgumentHandle* h, size_t size);
\end{apient}
\apidesc{
  Pops an parameter of current function call.
}

\begin{apient}
PayloadFunc entry() const;
\end{apient}
\apidesc{
  Returns entry payload function's address.
}

\begin{apient}
PayloadFunc exit() const;
\end{apient}
\apidesc{
  Returns exit payload function's address.
}

\begin{apient}
SpPoint* point() const;
\end{apient}
\apidesc{
  Returns the function call point where this code snippet is installed.
}


\subsubsection{Class SpAddrSpace}
\textbf{Declared in}: src/agent/patchapi/addr\_space.h

\begin{apient}
bool SetMemoryPermission(dt::Address addr,
                         size_t length,
                         int perm);
\end{apient}
\apidesc{
  Sets the permission of a range of memory area [{\em addr}, {\em addr} + length).
  The parameter {\em perm} is the same as the {\em prot} parameter in {\em mmap}
  system call (i.e., PROT_READ, PROT_WRITE, PROT_EXEC ... or combination of them
  PROT_READ | PROT_WRITE ...).

}

\begin{apient}
void InitMemoryAllocator();
\end{apient}
\apidesc{
  Initiates the customized memory allocator.
}

\subsubsection{Inst Workers}

This is a collection of instrumentation workers that install payload functions
to function call points.

\textbf{Class InstWorkerDelegate}

\textbf{Declared in}: src/agent/inst\_workers/inst\_worker\_delegate.h

This is the base class of instrumentation worker. Details of the instrumentation
engine can be found in Section~\ref{sec:intrainst}.

\begin{apient}
virtual bool run(SpPoint* pt);
\end{apient}
\apidesc{
Instruments a point.
}

\begin{apient}
virtual bool undo(SpPoint* pt);
\end{apient}
\apidesc{
Uninstruments a point.
(For now, this is not implemented yet.)
}

\begin{apient}
virtual bool save(SpPoint* pt);
\end{apient}
\apidesc{
Save code that will be modified for a point.
}

\begin{apient}
typedef enum {
  SP_NONE,
  SP_TRAP,      
  SP_RELOC_INSN,
  SP_RELOC_BLK, 
  SP_SPRINGBOARD
} InstallMethod;
virtual InstallMethod install_method() const;
\end{apient}
\apidesc{
Returns the method of instrumentation installation. 
}

\textbf{Class RelocCallInsnWorker}

\textbf{Declared in}: src/agent/inst\_workers/callinsn\_worker\_impl.h

This is to relocate a call instruction then install instrumentation.

\textbf{Class RelocCallBlockWorker}

\textbf{Declared in}: src/agent/inst\_workers/callblk\_worker\_impl.h

This is to relocate a call block then install instrumentation.

\textbf{Class SpringboardWorker}

\textbf{Declared in}: src/agent/inst\_workers/spring\_worker\_impl.h

This is to use springboard mechanism then install instrumentation.

\textbf{Class TrapWorker}

\textbf{Declared in}: src/agent/inst\_workers/trap\_worker\_impl.h

This is to use trap instruction to install instrumentation.

\subsubsection{Class SpThreadMgr}
\textbf{Declared in}: src/agent/thread\_mgr.h

This manages the instrumentation propagation across thread boundary.

\begin{apient}
static bool BeforeEntry(SpPoint*);
\end{apient}
\apidesc{
  This does the inter-thread instrumentation propagation.
}

\subsubsection{Class IpcMgr}
\textbf{Declared in}: src/agent/ipc/ipc\_mgr.h

This manages inter-process instrumentation propagation.

\begin{apient}
typedef enum {
  SP_READ,
  SP_WRITE,
  SP_NORW
} ChannelRW;
SpChannel* GetChannel(int fd,
                      ChannelRW rw);
\end{apient}
\apidesc{

  Returns a communication channel from a socket file descriptor {\em fd} with a
  specific channel type {\em rw} (i.e., write-only or read-only channel).

}

\begin{apient}
SpIpcWorkerDelegate* GetWorker(int fd);
\end{apient}
\apidesc{

  Returns an IPC worker according to a given file descriptor {\em fd} (i.e., TCP
  or pipe).

}

\begin{apient}
void GetWriteParam(SpPoint* pt,
                   int* fd_out,
                   void** buf_out,
                   char* c_out,
                   size_t* size_out,
                   sockaddr** sa_out);
\end{apient}
\apidesc{

  It fetches the arguments passed to the ``write'' function called at a point
  {\em pt}. The ``write'' function includes {\em write}, {\em send}, {\em
    fwrite}, ...

}

\begin{apient}
void GetReadParam(SpPoint* pt,
                  int* fd_out,
                  void** buf_out,
                  size_t* size_out);
\end{apient}
\apidesc{

  It fetches the arguments passed to the ``read'' function called at a point
  {\em pt}. The ``read'' function includes {\em read}, {\em recv}, {\em
    fread}, ...

}

\begin{apient}
bool is_fork(const char* func_name);
\end{apient}
\apidesc{

  Is the given function {\em func\_name} a {\em fork}?

}

\begin{apient}
bool IsPopen(const char* f);
\end{apient}
\apidesc{

  Is the given function {\em func\_name} a {\em popen}?

}

\begin{apient}
char CanStartTracing(int fd);
\end{apient}
\apidesc{

 See if current process is allowed to execute the payload code
 This is used in the user-defined payload function.
 Return 1 if it is allowed to execute payload code (for tracing);
 otherwise, 0 is returned.

}

\begin{apient}
static bool BeforeEntry(SpPoint*);
\end{apient}
\apidesc{

  Will be called before user-specified entry-payload function to do
  inter-process propagation.

}

\begin{apient}
static bool BeforeExit(SpPoint*);
\end{apient}
\apidesc{

  Will be called before user-specified entry-payload function to support
  inter-process propagation.

}

\begin{apient}
SpPipeWorker* pipe_worker() const;
\end{apient}
\apidesc{

  Returns the pipe worker that does inter-process propagation for pipe
  mechanism.

}

\begin{apient}
SpTcpWorker* tcp_worker() const;
\end{apient}
\apidesc{

  Returns the tcp worker that does inter-process propagation for tcp
  mechanism.

}

\begin{apient}
SpUdpWorker* udp_worker() const;
\end{apient}
\apidesc{

  Returns the udp worker that does inter-process propagation for udp
  mechanism. 
  (This hasn't been implemented yet.)

}

\subsubsection{Class SpChannel}
\textbf{Declared in}: src/agent/ipc/channel.h

\begin{apient}
struct SpChannel {
  SpChannel() :
  type(SP_UNKNOWN), injected(false), local_pid(-1), remote_pid(-1),
    remote_injected(false), inode(-1), fd(-1), rw(SP_WRITE) {}

  ChannelType type;      // Channel type
  bool injected;         // Already injected?
  pid_t local_pid;       // Sender's pid
  pid_t remote_pid;      // Receiver's pid
  bool remote_injected;  // Agent is already injected to receiver?
  ino_t inode;           // System-wide inode number
  int fd;                // local fd that represents this channel
  ChannelRW rw;          // Read or Write?
};

struct PipeChannel : public SpChannel {
  PipeChannel() : SpChannel() {}
};

struct TcpChannel : public SpChannel {
  TcpChannel() :
  SpChannel() {}
  sockaddr_storage local;
  sockaddr_storage remote;

  pid_t GetRemotePid();
  std::string GetLocalHost();
  std::string GetRemoteHost();
  int GetLocalPort();
  int GetRemotePort();
};
\end{apient}


\subsubsection{IPC Workers}
\textbf{Declared in}: src/agent/ipc/ipc\_workers/

This is a collection of IPC workers, each of which does inter-process
propagation for one type of IPC mechanism.

\textbf{Class SpIpcWorkerDelegate}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/ipc\_worker\_delegate.h

This is the base class for IPC worker.

\begin{apient}
virtual void SetRemoteStartTracing(char yes_or_no,
                                   SpChannel* c);
\end{apient}
\apidesc{

  This decides whether or not the user-defined logic in payload function code of
  the remote process can run.
  If the parameter {\em yes\_or\_no} is 0, then the remote process on the other
  end of channel {\em c} cannot use the user-defined logic in payload function;
  otherwise, the remote process can run the user-defined logic.

}

\begin{apient}
virtual void SetLocalStartTracing(char yes_or_no);
\end{apient}
\apidesc{
  This decides whether or not the user-defined logic in payload function code
  of current process can run.
  If the parameter {\em yes\_or\_no} is 0, then the current process cannot use
  the user-defined logic in payload function; otherwise, the remote process can
  run the user-defined logic.

}

\begin{apient}
virtual char CanStartTracing(int fd);
\end{apient}
\apidesc{
   Query if it's okay to trace on local end of the channel:
   For Write-channel, it always return 1 (true);
   2. For Read-channel, it should be synchronized by remote process
   This is used by the process who owns this Worker instance.

}

\begin{apient}
virtual bool Inject(SpChannel* c, char* agent_path = NULL);
\end{apient}
\apidesc{
  Inject the agent shared library to the other end of a channel {\em c}.
}

\begin{apient}
virtual SpChannel* GetChannel(int fd,
                              ChannelRW rw,
                              void* arg = NULL);
\end{apient}
\apidesc{
   Returns a communication channel from a file descriptor {\em fd}.
   Returns NULL if not a valid IPC channel.
}

\textbf{Class SpPipeWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/pipe\_worker\_impl.h

This handles inter-process propagation via pipe mechanism.

\textbf{Class SpTcpWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/tcp\_worker\_impl.h

This handles inter-process propagation via TCP mechanism.

\textbf{Class SpUdpWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/udp\_worker\_impl.h

This handles inter-process propagation via UDP mechanism.
(Not implemented yet.)
