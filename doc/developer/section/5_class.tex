\section{Class Reference}

% In both user and developer manual
\subsection{Interfaces for Users}
\subsubsection{Class Agent}
\textbf{Declared in}: src/agent/agent.h

\begin{apient}
void SetInitEntry(string);
\end{apient}
\apidesc{

Sets the entry payload function name. By default, the entry payload function is
``default\_entry'', which simply prints out all executed functions' name.

}

\begin{apient}
void SetInitExit(string);
\end{apient}
\apidesc{

Sets the exit payload function name. By default, there is not exit payload
function.

}

\begin{apient}
void SetLibrariesToInstrument(const StringSet& libs);
\end{apient}
\apidesc{

Sets the set of names of libraries loaded in the application process that will
be instrumented. By default, we only instrument the executable binary code and
don't instrument loaded shared libraries.

}

\begin{apient}
void SetFuncsNotToInstrument(const StringSet& funcs);
\end{apient}
\apidesc{
Sets the set of names of functions in the application process that will
NOT be instrumented. By default, we instrument all functions.
}

\begin{apient}
void EnableParseOnly(const bool yes_or_no);
\end{apient}
\apidesc{

Enables or disables ParseOnly option. If yes\_or\_no is true, then after parsing
the binary code, we don't do instrumentation; otherwise, instrumentation is
conducted after parsing. By default, ParseOnly option is disabled.

}

\begin{apient}
void EnableIpc(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable inter-process instrumentation propagation. By default,
inter-process instrumentation propagation is disabled.

}

\begin{apient}
void EnableHandleDlopen(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable propagating instrumentation to library loaded via dlopen. By
default, it is disabled.

}

\begin{apient}
void EnableMultithread(const bool yes_or_no);
\end{apient}
\apidesc{

Enable or disable propagating instrumentation across thread. By default, it is
disabled.

}

\begin{apient}
void Go();
\end{apient}
\apidesc{

Starts initial instrumentation.

}

\subsubsection{Class SpPoint}
\textbf{Declared in}: src/agent/patchapi/point.h

\begin{apient}
bool tailcall();
\end{apient}
\apidesc{

Indicates whether or not the function call at this point is a tail call.

}

\begin{apient}
SpBlock* GetBlock() const;
\end{apient}
\apidesc{

Returns the call block at this point.

}

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object at this point.
}


\subsubsection{Class SpObject}
\textbf{Declared in}: src/agent/patchapi/object.h

\begin{apient}
std::string name() const;
\end{apient}
\apidesc{
Returns the binary object's name.
}

This class inherits PatchAPI::PatchObject. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Class SpFunction}
\textbf{Declared in}: src/agent/patchapi/cfg.h

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object containing this function.
}

\begin{apient}
std::string GetMangledName();
\end{apient}
\apidesc{
Returns the mangled name of this function.
}

\begin{apient}
std::string GetPrettyName();
\end{apient}
\apidesc{
Returns the demangled name of this function.
}

\begin{apient}
std::string name();
\end{apient}
\apidesc{
Returns the demangled name of this function, the same as calling GetPrettyName().
}

This class inherits PatchAPI::PatchFunction. Please refer to PatchAPI document
for the complete list of methods.

\subsubsection{Class SpBlock}
\textbf{Declared in}: src/agent/patchapi/cfg.h

\begin{apient}
SpObject* GetObject() const;
\end{apient}
\apidesc{
Returns the binary object containing this block.
}

\begin{apient}
in::Instruction::Ptr orig_call_insn() const;
\end{apient}
\apidesc{

Returns an InstructionAPI::Instruction instance of the call instruction in this
block.

}

This class inherits PatchAPI::PatchBlock. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Class SpEdge}
\textbf{Declared in}: src/agent/patchapi/cfg.h

This class inherits PatchAPI::PatchEdge. Please refer to PatchAPI document for
the complete list of methods.

\subsubsection{Utility Functions}
\textbf{Declared in}: src/agent/payload.h

Utility functions are used when writing payload functions.

\begin{apient}
SpFunction* Callee(SpPoint* pt);
\end{apient}
\apidesc{
Returns an instance of SpFunction for current function call. 
The argument \emph{pt} represents the instrumentation point for current function
call.
If it fails, it returns NULL.
}

\begin{apient}
bool IsInstrumentable(SpPoint* pt);
\end{apient}
\apidesc{
Indicates whether or not the point is instrumentable.
}

\begin{apient}
void Propel(SpPoint* pt);
\end{apient}
\apidesc{

Propagates instrumentation to callees of the function called at the specified
point {\em pt}.

}

\begin{apient}
bool IsIpcWrite(SpPoint* pt); 
bool IsIpcRead(SpPoint* pt); 
\end{apient}
\apidesc{

Indicates whether or not the function called at the specified point is a
inter-process communication write / read function.

}

\begin{apient}
struct ArgumentHandle;
void* PopArgument(SpPoint* pt,
                  ArgumentHandle* h,
                  size_t size);
\end{apient}
\apidesc{

Gets a pointer to an argument of the function call at the specified point {\em
  pt}.
All arguments passed to the function call are in a stack associated with the
ArgumentHandle structure {\em h}. 
Leftmost argument is at the top of the stack.
The {\em size} parameter specifies the size of the argument that is about to be
popped.

}

\begin{apient}
long ReturnValue(SpPoint* pt);
\end{apient}
\apidesc{
Returns the return value of the function call at the specified point {\em pt}.
}

% In developer manual only
\subsection{Interfaces for Developers}
\subsubsection{Class SpParser}
\textbf{Declared in}: src/agent/parser.h

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpParser instance.
}

\begin{apient}
SpObject* exe() const;
\end{apient}
\apidesc{
Returns the executable's binary object.
}

\begin{apient}
PatchAPI::PatchMgrPtr Parse();
\end{apient}
\apidesc{ The major parsing method, which builds CFG data structures to assist
  instrumentation.  }

\begin{apient}
string agent_name()
\end{apient}
\apidesc{
Returns the agent library's full path name.
}

\begin{apient}
bool injected()
\end{apient}
\apidesc{

  Indicates whether or not this agent library is injected in the middle of
  running current process.

}

\begin{apient}
void GetFrame(long* pc, long* sp, long* bp)
\end{apient}
\apidesc{

  Get the values of three registers (pc, sp, and bp) of the call frame where the
  agent is injected. The three arguments are output arguments.

}

\begin{apient}
SpFunction* FindFunction(dt::Address absolute_addr);
\end{apient}
\apidesc{

  Returns the function that contains the address {\em absolute_addr}.
  It returns NULL if no function is found.
}

\begin{apient}
SpFunction* FindFunction(string mangled_name);
\end{apient}
\apidesc{

  Returns one of the functions that have the mangled function name.
  It returns NULL if no function is found.
}

\begin{apient}
bool FindFunction(string func_name, FuncSet* found_funcs);
\end{apient}
\apidesc{

  Get all the functions that have the demangled function name.

}

\begin{apient}
SpFunction* callee(SpPoint* point, bool parse_indirect = false);
\end{apient}
\apidesc{

  Returns the callee at the given call {\em point}.
  If {\em parse\_indirect} is false and the call instruction is an indirect call
  instruction, then we skip parsing it and return NULL immediately.
  If the callee is not found, NULL is returned.
}

\begin{apient}
string DumpInsns(void* addr, size_t size);
\end{apient}
\apidesc{

  Returns a nice textual representation of all instructions at the memory area of [{\em
    addr}, {\em addr} + size].

}

\begin{apient}
static bool ParseDlExit(SpPoint* pt);
\end{apient}
\apidesc{

  Detects the dlopen function call, and parses the library that is just loaded.
  It is invoked immediately after the dlopen function call is returned.
}

\subsubsection{Class SpContext}
\textbf{Declared in}: src/agent/context.h

\begin{apient}
static SpContext* Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpContext instance.

}

\begin{apient}
string init_entry_name() const
\end{apient}
\apidesc{
  Returns initial entry payload function's demangled name.
}

\begin{apient}
string init_exit_name() const
\end{apient}
\apidesc{
  Returns initial exit payload function's demangled name.
}

\begin{apient}
typedef std::set<SpFunction*> FuncSet;
void GetCallStack(FuncSet* func_set);
\end{apient}
\apidesc{
  Get a set of functions in the call stack, when the agent library is injected.
  {\em func\_set} is the output argument.
}


\begin{apient}
bool IsMultithreadEnabled() const;
\end{apient}
\apidesc{
  Indicates whether instrumentation propagation across thread boundary is supported.
}

\begin{apient}
bool IsHandleDlopenEnabled() const;
\end{apient}
\apidesc{
  Indicates whether parsing newly loaded shared library is supported.
}

\begin{apient}
bool IsDirectcallOnlyEnabled() const;
\end{apient}
\apidesc{

  Indicates whether or not self-propelled instrumentation only instruments
  direct function call.

}

\begin{apient}
SpPropeller::ptr init_propeller() const;
\end{apient}
\apidesc{
  Returns an instance of SpPropeller.
}

\begin{apient}
typedef void* PayloadFunc;
PayloadFunc init_entry() const;
PayloadFunc init_exit() const;
\end{apient}
\apidesc{

  Returns the start address of user-provided entry payload function or exit
  payload function.

}

\begin{apient}
PayloadFunc wrapper_exit() const;
PayloadFunc wrapper_entry() const;
\end{apient}
\apidesc{

  Returns the start address of the wrapper of entry payload function or exit
  payload function.
  
}

\subsubsection{Events}
\textbf{Declared in}: src/agent/event.h

This is a collection of events that trigger initial instrumentation.

\textbf{Class SpEvent}

It is the base class of all event classes. This event does not trigger any
instrumentation.

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpEvent instance.

}

\begin{apient}
virtual void RegisterEvent();
\end{apient}
\apidesc{
It registers the event to agent. This function is called in Agent::Go().
}

\textbf{Class AsyncEvent}

It is the asynchronous event that will happen when specified signal occurs.

\begin{apient}
static ptr Create(int signum = SIGALRM,
                  int sec = 5);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a AsyncEvent instance.

The argument {\em signum} specifies the signal number, and the argument {\em
  sec} is only effective when signum is SIGALRM.

}

\textbf{Class SyncEvent}

It is the synchronous event that will do instrumentation immediately.
If the agent library is loaded via LD\_PRELOAD, then it instruments main()
function immediately.
If the agent library is injected via injector, then it instruments all functions
in the call stack when the agent library is loaded.

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SyncEvent instance.

}

\textbf{Class FuncEvent}

It instruments all of the specified functions immediately.

\begin{apient}
static ptr Create(StringSet& funcs);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a FuncEvent instance.
The argument {\em funcs} specifies a set of demangled names of functions that
are going to be instrumented.  
}

\textbf{Class CallEvent}

It installs instrumentation at all call sites of specified functions immediately.

\begin{apient}
static ptr Create(StringSet& funcs);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a CallEvent instance.
The argument {\em funcs} specifies a set of demangled names of function calls
that are going to be instrumented.

}

\textbf{Class CombEvent}

It is a compound event that can combine all the above events.

\begin{apient}
static ptr Create(EventSet& events);
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a CombEvent instance.
The argument {\em events} specifies a set of events.

}

\subsubsection{Class SpPropeller}
\textbf{Declared in}: src/agent/propeller.h

\begin{apient}
static ptr Create();
\end{apient}
\apidesc{
Creates a Boost shared pointer pointing to a SpPropeller instance.

}

\begin{apient}
bool go(SpFunction* func,
        PayloadFunc entry,
        PayloadFunc exit,
        SpPoint* pt = NULL,
        StringSet* inst_calls = NULL);
\end{apient}
\apidesc{

  It propagates instrumentation to callees of specified function {\em func}.
  The arguments {\em entry} and {\em exit} specify the payload functions to be
  installed for those callees.  
  The argument {\em point} is the point where {\em func} is invoked.
  The argument {\em inst_calls} specifies all function calls that need to be
  instrumented, which is used only in CallEvent.

}

\subsubsection{Class SpSnippet}
\textbf{Declared in}: src/agent/snippet.h

\begin{apient}
static ptr create(SpFunction* f,
                  SpPoint* pt,
                  PayloadFunc entry,
                  PayloadFunc exit);
\end{apient}
\apidesc{
  Creates a Boost shared pointer pointing to a SpSnippet instance.
}

\begin{apient}
char* BuildBlob(const size_t est_size,
                const bool reloc = false);
\end{apient}
\apidesc{
}

\begin{apient}
size_t GetBlobSize() const;
\end{apient}
\apidesc{
}

\begin{apient}
SpBlock* FindSpringboard();
\end{apient}
\apidesc{
}

\begin{apient}
char* RelocateSpring(SpBlock* spring_blk);
\end{apient}
\apidesc{
}

\begin{apient}
size_t GetRelocSpringSize() const;
\end{apient}
\apidesc{
}

\begin{apient}
dt::Address GetSavedReg(dt::MachRegister reg);
\end{apient}
\apidesc{
}

\begin{apient}
long GetRetVal();
\end{apient}
\apidesc{
}

\begin{apient}
void* PopArgument(ArgumentHandle* h, size_t size);
\end{apient}
\apidesc{
}

\begin{apient}
PayloadFunc entry() const;
\end{apient}
\apidesc{
}

\begin{apient}
PayloadFunc exit() const;
\end{apient}
\apidesc{
}

\begin{apient}
SpPoint* point() const;
\end{apient}
\apidesc{
}


\subsubsection{Class SpAddrSpace}
\textbf{Declared in}: src/agent/patchapi/addr\_space.h

\begin{apient}
bool SetMemoryPermission(dt::Address addr,
                         size_t length,
                         int perm);
\end{apient}
\apidesc{
}

\begin{apient}
void InitMemoryAllocator();
\end{apient}
\apidesc{
}

\subsubsection{Inst Workers}

\textbf{Class InstWorkerDelegate}

\textbf{Declared in}: src/agent/inst\_workers/inst\_worker\_delegate.h

\begin{apient}
virtual bool run(SpPoint* pt);
\end{apient}
\apidesc{
Instrument a point.
}

\begin{apient}
virtual bool undo(SpPoint* pt);
\end{apient}
\apidesc{
Uninstrument a point.
}

\begin{apient}
virtual bool save(SpPoint* pt);
\end{apient}
\apidesc{
Save code that will be modified for a point.
}

\begin{apient}
virtual InstallMethod install_method() const;
\end{apient}
\apidesc{
Returns the method of instrumentation installation.
}

\textbf{Class RelocCallInsnWorker}

\textbf{Declared in}: src/agent/inst\_workers/callinsn\_worker\_impl.h

\textbf{Class RelocCallBlockWorker}

\textbf{Declared in}: src/agent/inst\_workers/callblk\_worker\_impl.h

\textbf{Class SpringboardWorker}

\textbf{Declared in}: src/agent/inst\_workers/spring\_worker\_impl.h

\textbf{Class TrapWorker}

\textbf{Declared in}: src/agent/inst\_workers/trap\_worker\_impl.h


\subsubsection{Class SpThreadMgr}
\textbf{Declared in}: src/agent/thread\_mgr.h

\begin{apient}
static bool BeforeEntry(SpPoint*);
\end{apient}
\apidesc{
}

\subsubsection{Class IpcMgr}
\textbf{Declared in}: src/agent/ipc/ipc\_mgr.h

\begin{apient}
SpChannel* GetChannel(int fd,
                      ChannelRW rw);
\end{apient}
\apidesc{
}

\begin{apient}
SpIpcWorkerDelegate* GetWorker(int fd);
\end{apient}
\apidesc{
}

\begin{apient}
void GetWriteParam(SpPoint* pt,
                   int* fd_out,
                   void** buf_out,
                   char* c_out,
                   size_t* size_out,
                   sockaddr** sa_out);
\end{apient}
\apidesc{
}

\begin{apient}
void GetReadParam(SpPoint* pt,
                  int* fd_out,
                  void** buf_out,
                  size_t* size_out);
\end{apient}
\apidesc{
}

\begin{apient}
bool is_fork(const char* f);
\end{apient}
\apidesc{
}

\begin{apient}
bool is_popen(const char* f);
\end{apient}
\apidesc{
}

\begin{apient}
char start_tracing(int fd);
\end{apient}
\apidesc{
}

\begin{apient}
static bool BeforeEntry(SpPoint*);
\end{apient}
\apidesc{
}

\begin{apient}
static bool BeforeExit(SpPoint*);
\end{apient}
\apidesc{
}

\begin{apient}
SpPipeWorker* pipe_worker() const;
\end{apient}
\apidesc{
}

\begin{apient}
SpTcpWorker* tcp_worker() const;
\end{apient}
\apidesc{
}

\begin{apient}
SpUdpWorker* udp_worker() const;
\end{apient}
\apidesc{
}

\subsubsection{Class SpChannel}
\textbf{Declared in}: src/agent/ipc/channel.h

\subsubsection{IPC Workers}
\textbf{Declared in}: src/agent/ipc/ipc\_workers/

\textbf{Class SpIpcWorkerDelegate}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/ipc\_worker\_delegate.h

\begin{apient}
virtual void SetStartTracing(char yes_or_no,
                             SpChannel* c);
\end{apient}
\apidesc{
}

\begin{apient}
virtual void SetStartTracing(char yes_or_no);
\end{apient}
\apidesc{
}

\begin{apient}
virtual char start_tracing(int fd);
\end{apient}
\apidesc{
}

\begin{apient}
virtual bool Inject(SpChannel*, char* agent_path = NULL);
\end{apient}
\apidesc{
}

\begin{apient}
virtual SpChannel* GetChannel(int fd,
                              ChannelRW rw,
                              void* arg = NULL);
\end{apient}
\apidesc{
}

\textbf{Class SpPipeWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/pipe\_worker\_impl.h

\textbf{Class SpTcpWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/tcp\_worker\_impl.h

\textbf{Class SpUdpWorker}

\textbf{Declared in}: src/agent/ipc/ipc\_workers/udp\_worker\_impl.h
