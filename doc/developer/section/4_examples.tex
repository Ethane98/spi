\section{Examples}
To illustrate the ideas of Self-propelled instrumentation, we present some
simple code examples that demonstrate how the API can be used.

\subsection{Writing Payload}
The primary task for users using self-propelled instrumentation is write
payload
functions that are invoked before or after each function call.
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Writing payload functions]
// Entry payload function that is invoked before each function call
void entry_payload(SpPoint* pt) {
  // Get function from point
  SpFunction* func = sp::Callee(pt);
  if (func == NULL) return;

  // If we encounter the system call exit, then print its argument
  if (func->name().compare("exit") == 0) {
    // Get argument
    sp::ArgumentHandle h;
    int* exit_code = (int*)sp::PopArgument(pt, &h, sizeof(int));
    printf("Exit Code: %d\n", *exit_code);
  }
  sp::Propel(pt);
}

// Exit payload function that is invoked after each function call
void exit_payload(SpPoint* pt) {
  // Get function from point
  SpFunction* func = sp::Callee(pt);
  if (func == NULL) return;

  // If we encounter the system call fork, then print its return value
  if (func->name().compare("fork") == 0) {
    pid_t child_pid = sp::ReturnValue(pt);
    // Print child process id from parent process side
    if (child_pid > 0) {
      printf("Child process id: %d\n", child_pid);
    }
  }
}
\end{lstlisting}
In the above code, we illustrate some common operations that users may want to
do in entry payload function or exit payload function.
Users can get CFG structures (e.g., function, block ...) from the argument {\em
  pt}.
Typically, there are some conditional branches to handle different functions,
e.g., handling exit and fork in the above code.
Users can also get arguments or return value for current function call.

\subsection{Configuration}
Users also need to provide the configuration code in the constructor
function of
the Agent shared library, which is mainly to register the user-provided payload
functions.
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Configuration code]
__attribute__((constructor))
void MyAgent() {
  sp::SpAgent::ptr agent = sp::SpAgent::Create();
  // Register entry payload function
  agent->SetInitEntry("entry_payload");
  // Register exit payload function
  agent->SetInitExit("exit_payload");
  // Initiate instrumentation
  agent->Go();
}
\end{lstlisting}
The above code shows the minimum operations needed to configure self-propelled
instrumentation.  The major things to do in the configuration code are to create
an Agent object that manages configurations, registers payload functions, and
initiates instrumentation.

\subsection{Using Injector}
The injector can be used to inject the agent shared library into a process. It
can also be injected to monitor all the processes running on a specific
port. The injector executable can be found inside $\$SP\_DIR/\$PLATFORM$. To
instrument a particular process with process id $pid$, use the following command

\apidesc{

./injector pid $pid$ LIB\_NAME

}

Similarly, to instrument all the processes running on a specific port,
use the following command

\apidesc{

./injector port $port$ LIB\_NAME

}



\subsection{Extending SPI}
This subsection discusses some code examples to extend self-propelled
instrumentation.
\subsubsection{Parser}
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Use customized parser]
// Extend SpParser and override the Parse() method to customize the parsing logic
class  MyParser : public SpParser {
  public:
    typedef SHARED_PTR(MyParser) ptr;
    AGENT_EXPORT static ptr Create() { return ptr(new MyParser); }
    AGENT_EXPORT virtual PatchAPI::PatchMgrPtr Parse() {
      // Implement your own parsing logic
    }
};

// Register the customized parser to self-propelled instrumentation
__attribute__((constructor))
void MyAgent() {
  sp::SpAgent::ptr agent = sp::SpAgent::Create();
  MyParser::ptr parser = MyParser::Create();
  agent->SetParser(parser);
  ...
}
\end{lstlisting}
The above code first extends SpParser to implement a customized parser for
parsing binary code into CFG structures. Developers mainly need to implement the
{\em Parse} method. Next, we register the customized parser in the agent library
by using {\em SpAgent::SetParser} method.

\subsubsection{Event}
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Use customized event]
// Extend SpEvent and override the RegisterEvent() method to do 
// initial instrumentation
class  MyEvent : public SpEvent {
  public:
    typedef SHARED_PTR(MyEvent) ptr;
    static ptr Create() { return ptr(new MyEvent()); }
    virtual void RegisterEvent() {}
};

// Register the customized event to self-propelled instrumentation
__attribute__((constructor))
void MyAgent() {
  sp::SpAgent::ptr agent = sp::SpAgent::Create();
  MyEvent::ptr event = MyEvent::Create();
  agent->SetInitEvent(event);
  ...
}
\end{lstlisting}
The above code first extends SpEvent to implement the {\em RegisterEvent} method
that does initial instrumentation. Next, we register the customized event in
the agent library by using {\em SpAgent::SetInitEvent} method.

\subsubsection{Instrumentation Workers}
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Use customized instrumentation worker]
// Extend InstWorkerDelegate to build a customized instrumentation worker
class MyInstWorker : public InstWorkerDelegate {
  public:
		// Instrument a point
    virtual bool run(SpPoint* pt) {}

		// Uninstrument a point
		virtual bool undo(SpPoint* pt) {}

		// Save code that will be modified for a point
		virtual bool save(SpPoint* pt) {}

		// How to install instrumentation?
		virtual InstallMethod install_method() {}
};

// Register MyInstWorker in the instrumenter
SpInstrumenter::SpInstrumenter(ph::AddrSpace* as) {
  ...
	workers_.push_back(new SpringboardWorker);
	workers_.push_back(new TrapWorker);
	workers_.push_back(new MyInstWorker);
  ...
}
\end{lstlisting}


\subsubsection{IPC Workers}
\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left}
\begin{lstlisting}[caption=Use customized IPC worker]
class  MyIpcWorker : public SpIpcWorkerDelegate {
  public:
    virtual void SetRemoteStartTracing(char yes_or_no,
                                       SpChannel* c) {}
    virtual void SetLocalStartTracing(char yes_or_no) {}
    virtual char CanStartTracing(int fd) {}
    virtual bool Inject(SpChannel*, char* agent_path = NULL) {}
    virtual SpChannel* GetChannel(int fd,
                                  ChannelRW rw,
                                  void* arg = NULL) {}
    virtual void CloseChannel(int fd) {}
};

// Register MyIpcWorker to self-propelled instrumentation
SpIpcMgr::SpIpcMgr() {
  ...
  pipe_worker_ = new SpPipeWorker;
  worker_set_.insert(pipe_worker_);

  tcp_worker_ = new SpTcpWorker;
  worker_set_.insert(tcp_worker_);
  
  my_ipc_worker_ = new MyIpcWorker;
  worker_set_.insert(my_ipc_worker_);
  ...
}
\end{lstlisting}
