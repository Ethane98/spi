% This is only for developer manual
\section{Internals}

This section describes the detailed internal design of self-propelled
instrumentation, from developer's perspective.
Current implementation is on Linux.

\subsection{Injector}

The main injection procedure, which has two main steps:
\begin{itemize}
\item Force an application process to execute {\em do\_dlopen} or {\em
    \_\_libc\_dlopen\_mode} functions in libc.so to load shared library
  libijagent.so. We use ProccontrolAPI's IRPC mechanism to remotely invoke
  functions.
\item Force an application process to execute {\em ij\_agent} function in
  libijagent.so to load the user-specified shared library. In this step, we have
  to pass parameters from injector to the application process by IPC mechanism,
  where we use shared memory in current implementation and the shared memory id
  is 1986. If the application also notifies the injector via shared memory
  whether the library loading is successful.
\end{itemize}

Here are some design rationales:

\textbf{Why don't we directly use do\_dlopen or \_\_libc\_dlopen\_mode to load
  user-specified shared library?}  Because do\_dlopen is not a public function,
which is unsafe to use.  Oftentimes, do\_dlopen causes the application process
to crash, e.g., the library is not found. On the other hand, dlopen is safe to
use, which would not causes the application process to crash.

\textbf{To follow up the above question, since dlopen is safe to use, why don't
  we directly call dlopen to load user-specified library?}  We are not allowed
to do so. libc.so has sanity check on calling dlopen. If we call dlopen using
IRPC, dlopen would fail, although it won't crash injectee process. In sum, the
benefit of providing a level of indirection is, we can use unsafe do\_dlopen
function to load a controlled library libijagent.so, from libijagent.so, we use
safe dlopen function to load uncontrolled user-provided library.


\textbf{Why sometimes we may use \_\_libc\_dlopen\_mode?} Because ... if libc is
stripped, then we cannot find do\_open, but we can still find
\_\_libc\_dlopen\_mode.


\textbf{Why we use IPC mechanism to pass parameters to ij\_agent in
  libijagent.so?}  ij\_agent is a function that calls dlopen. After dlopen is
invoked, we want to check whether the loading is successful. Even when dlopen
fails, we also want to know the error message. Therefore, we need to do IPC for
error report or checking return value. In this case, why don't we have an easy
and uniformed way to pass argument and check return value?

\subsection{Agent}
\subsubsection{Parsing}

When Agent library is loaded, it needs to parse the binary code into PatchAPI
CFG (Control Flow Graph) structures that are used in later instrumentation.

The parsing is done in {\em SpParser::Parse}, which consists of these steps:
\begin{itemize}
\item Parse binary code into SymtabAPI::Symtab objects.
\item Use SymtabAPI::Symtab objects to create SpObject (subclass of
  PatchAPI::PatchObject) objects, which indirectly relies on {\em
    ParseAPI::parse} to do the runtime parsing.
\end{itemize}

\subsubsection{Initial Instrumentation}

Initial instrumentation is encapsulated in SpEvent series classes. 

In particular, for SyncEvent, we make the semantics to be ``do initial
instrumentation right away''. We handle this in two cases. If the agent library
is injected via an injector, we instrument all functions in the call stack when
injection happens, using StackwalkerAPI. If the agent library is loaded at the
beginning of running a application process via setting LD_PRELOAD environment
variable, then we instrument {\em main} function.


\subsubsection{Intra-process Propagation} \label{sec:intrainst}

The instrumentation is to transfer control from original binary code in an
application process to a snippet of code that is built by self-propelled
instrumentation. This snippet of code contains these things in order:
\begin{itemize}
\item Relocated code, which may be a relocated call instruction or a relocated
  call block, depending on what instrumentation worker is used.
\item Context saving code, which saves registers in the stack.
\item Code to invoke an entry payload function.
\item Context restoring code, which restores registers from the stack.
\item Code to invoke the original function being instrumented.
\item Context saving code, which saves registers in the stack (OPTIONAL).
\item Code to invoke an exit payload function (OPTIONAL).
\item Context restoring code, which restores registers from the stack (OPTIONAL).
\item Code to jump back to the original code.
\end{itemize}

To install instrumentation to a function call, we try these instrumentation
workers in order:
\begin{itemize}
\item RelocCallInsnWorker: Relocates call instruction and replaces the call
  instruction with a jump instruction. This may fail because a jump instruction
  may be larger than a call instruction.
\item RelocCallBlockWorker: Relocates call block and replaces the call block with
  a jump instruction. This may fail because a jump instruction may be larger
  than a call block.
\item SpringboardWorker: Relocates call block C and replaces the call block with
  a short jump that transfers control to a nearby block as springboard block
  S. Relocates S and replace S with two jump instructions, one of which jumps to
  the relocated S (denoted as S'), and the other jumps to the snippet. To sum
  up, C -> S -> S' -> S -> snippet -> C. This may fail because a springboard
  block that is large enough to place two long jumps may not be found.
\item TrapWorker: Relocates call instruction and replaces it with a trap
  instruction.
\end{itemize}

\subsubsection{Inter-process Propagation}
The current implementation of inter-process propagation supports two IPC
(inter-process communication) mechanisms, pipe and tcp.

% Pipe

% TCP

\subsubsection{Inter-thread Propagation}

The inter-thread instrumentation propagation is implemented in the SpThreadMgr
class. The basic idea is, when detecting {\em pthread\_create}, we get its first
argument, which is the address for the routine that will be run on a new thread.
Next, we find a function according to this function address, then we instrument
the function's callees.


\subsubsection{x86\_64 Issues}
% Memory allocator, long jump
% PC register thing

\subsubsection{Miscellaneous}
% Parsing library

% Thread-safe, locking
